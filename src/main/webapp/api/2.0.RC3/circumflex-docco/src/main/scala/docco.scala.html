
<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" media="screen, projection" href="/css/main.css" />
  <link rel="stylesheet" media="screen, projection" href="/css/colorbox.css" />
  <link rel="stylesheet" media="print" href="/css/print.css" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
  <link rel="icon" href="/favicon.ico" type="image/x-icon"/>
  <meta name="google-site-verification" content="8igpdSJ4tgF2EKKuvmA5GOWzRLKHozE5Aun82c5NQZY" />
  <meta name='yandex-verification' content='443ed98406777aa4' />
  <meta name='yandex-verification' content='59d4a20bb51bbfea' />
  <script type="text/javascript" src="http://www.google-analytics.com/ga.js">
  </script>
  <script src="/js/highlight.pack.js"></script>
  <script src="/js/jquery-1.4.2.min.js"></script>
  <script src="/js/jquery.colorbox-min.js"></script>
  <script src="/js/application.js"></script>
    <title>
        Circumflex &mdash; exquisite taste of Scala development
  </title>
</head>
<body>
<div id="header">
  <div class="wrap">
    <h1>
      <a href="/" title="Home">C&icirc;rcumflex</a>
    </h1>
    <span class="aside">exquisite taste of <a href="http://scala-lang.org">Scala</a> development</span>
  </div>
</div>
<div id="docco-page">
  <h1 id="docco-back">
    <a href="../../../../index.html" title="Back to index">&larr;</a>&nbsp;&nbsp;docco.scala
  </h1>
  <table cellspacing="0" cellpadding="0">
    <tbody>
      <tr id="section-0">
        <td class="docs">
          
        </td>
        <td class="code">
          <pre class="scala"><code>package ru.circumflex.docco

import ru.circumflex.core._
import ru.circumflex.freemarker._
import java.io._
import ru.circumflex.markeven
import org.apache.commons.io.filefilter.{TrueFileFilter, RegexFileFilter}
import java.util.{Collection =&gt; JCollection}
import collection.mutable.ListBuffer
import org.apache.commons.io.{FilenameUtils, IOUtils, FileUtils}

case class Section(private var _doc: String = &quot;&quot;, private var _code: String = &quot;&quot;) {

  private var _committed = false
  def committed_?() = _committed

  protected def trimNewLines(s: String) =
    s.replaceAll(&quot;^\\n+(.*)&quot;, &quot;$1&quot;).replaceAll(&quot;(.*?)\\n+$&quot;, &quot;$1&quot;)

  private var _md: String = null

  def addCode(s: String): this.type = {
    _committed = true
    _code += s + &quot;\n&quot;
    return this
  }
  def code = trimNewLines(_code)

  def addDoc(s: String): this.type = {
    _doc += s + &quot;\n&quot;
    _md = null
    return this
  }
  def doc: String = {
    if (_md == null)
      _md = markeven.toHtml(_doc)
    return _md
  }

  def empty_?() = _doc == &quot;&quot; &amp;&amp; _code == &quot;&quot;
}</code></pre>
        </td>
      </tr>
      <tr id="section-1">
        <td class="docs">
          <h1>Documenting Scala files with Docco</h1>
<p>This utility generates a user-friendly HTML for specified Scala source file by placing documentation and corresponding code blocks side by side.</p>
<p>The usage is trivial:</p>
<pre><code>Docco("my.scala").toHtml("my.scala.html")</code></pre>
<p>or shortcut of above:</p>
<pre><code>Docco("my.scala").toHtml</code></pre>
<p>Docco uses <a href="http://freemarker.org" title="FreeMarker Templating Engine">FreeMarker</a> to process pages, so you can provide your own FreeMarker <code>Configuration</code> and templates.</p>

        </td>
        <td class="code">
          <pre class="scala"><code>object Docco {
  def apply(sourceFile: String, stripScaladoc: Boolean = true): Docco =
    new Docco(new File(sourceFile), stripScaladoc)
}

class Docco(val file: File, val stripScaladoc: Boolean = true) {

  val pageTemplate: String = cx.get(&quot;docco.pageTemplate&quot;)
      .map(_.toString).getOrElse(&quot;/docco-single-page.html.ftl&quot;)
  val docSingleLine = &quot;^\\s*/\\*!\\s*(.*?)\\*/&quot;.r
  val docBegin = &quot;^(\\s*)/\\*!\\s*(.*)&quot;.r
  val docEnd = &quot;(.*?)\\*/\\s*&quot;.r
  val scaladocBegin = &quot;^(\\s*)/\\*\\*(.*)&quot;.r

  val sections = {
    var result = new ListBuffer[Section]
    var section = new Section()
    val reader = new BufferedReader(new FileReader(file))
    var insideDoc = false
    var insideScaladoc = false
    var indent = &quot;&quot;
    def flushSection(): Unit = {
      if (!section.empty_?)
        result ++= List(section)
      section = new Section()
    }
    try {
      var str = reader.readLine
      while (str != null) {
        str match {
          case docSingleLine(s) if (!insideScaladoc) =&gt;
            if (section.committed_?)
              flushSection
            section.addDoc(s)
            insideDoc = false
          case docBegin(i, s) if (!insideScaladoc) =&gt;
            if (section.committed_?)
              flushSection
            section.addDoc(s)
            indent = i
            insideDoc = true
          case scaladocBegin(i, s) if (!insideDoc) =&gt;
            insideScaladoc = true
            if (!stripScaladoc) section.addCode(str)
          case docEnd(s) =&gt;
            if (insideDoc)
              section.addDoc(s)
            if (insideScaladoc &amp;&amp; !stripScaladoc)
              section.addCode(str)
            insideDoc = false
            insideScaladoc = false
          case s =&gt; {
            if (insideDoc) {
              section.addDoc(s.replaceAll(&quot;^&quot; + indent, &quot;&quot;))
            } else {
              if (!insideScaladoc || !stripScaladoc)
                section.addCode(s)
            }
          }
        }
        str = reader.readLine
      }
      flushSection
    } finally {
      reader.close()
    }
    result
  }


  def toHtml(writer: Writer): Unit = ftlConfig.getTemplate(pageTemplate)
      .process(Map[String, Any](&quot;title&quot; -&gt; file.getName, &quot;sections&quot; -&gt; sections), writer)

  def toHtml(file: File): Unit = {
    val fw = new FileWriter(file)
    try {
      toHtml(fw)
    } finally {
      fw.close
    }
  }

  def toHtml(file: String): Unit = toHtml(new File(file))

  def toHtml(): Unit = toHtml(file.getAbsolutePath + &quot;.html&quot;)

}</code></pre>
        </td>
      </tr>
      <tr id="section-2">
        <td class="docs">
          <h2>Batch processing</h2>
<p>This utility generates Docco for specified <code>docco.basePath</code> configuration parameter. It is intended to build a documentation suite for arbitrary Maven project. The documentation is saved in location defined by <code>docco.outputDirectory</code> configuration parameter and contains:</p>
<ul>
  <li><code>index.html</code>;</li>
  <li>generated subfolders and documentation;</li>
  <li>custom resources in <code>.docco</code>.</li>
</ul>

        </td>
        <td class="code">
          <pre class="scala"><code>class DoccoBatch {
  // Base path for crawler
  val basePath: File = cx.get(&quot;docco.basePath&quot;) match {
    case Some(f: File) =&gt; f
    case Some(s: String) =&gt; new File(s)
    case _ =&gt; new File(&quot;.&quot;)
  }
  val outputPath = cx.get(&quot;docco.outputPath&quot;) match {
    case Some(f: File) =&gt; f
    case Some(s: String) =&gt; new File(s)
    case _ =&gt; new File(&quot;target/docco&quot;)
  }
  // Where should we store results of our work?
  // Templates
  val pageTemplate: String = cx.get(&quot;docco.pageTemplate&quot;)
      .map(_.toString).getOrElse(&quot;/docco-batch-page.html.ftl&quot;)
  val indexTemplate: String = cx.get(&quot;docco.indexTemplate&quot;)
      .map(_.toString).getOrElse(&quot;/docco-index.html.ftl&quot;)
  // Regex to filter sources
  val filenameRegex = cx.get(&quot;docco.filenameRegex&quot;).map(_.toString)
      .getOrElse(&quot;.*\\.scala$&quot;)
  // Custom resources
  var customResources: List[String] = Nil
  // Title for index
  val title: String = cx.get(&quot;docco.title&quot;).map(_.toString)
      .getOrElse(basePath.getCanonicalFile.getName + &quot; index&quot;)
  // Should we strip Scaladoc ( /** ... */ ) or not?
  val stripScaladoc: Boolean = cx.get(&quot;docco.stripScaladoc&quot;)
      .map(_.toString.toBoolean).getOrElse(true)
  // Should we ignore files with no docco?
  val skipEmpty: Boolean = cx.get(&quot;docco.skipEmpty&quot;)
      .map(_.toString.toBoolean).getOrElse(true)

  def addCustomResource(v: String) = { customResources ++= List(v) }

  def prepareCustomResources: Unit =
    if (customResources.size &gt; 0) {
      val customResDir = new File(outputPath, &quot;.docco&quot;)
      // create output directories if they do not already exist
      FileUtils.forceMkdir(customResDir)
      // copy resources
      customResources.foreach { r =&gt;
        var f = new File(r)
        if (f.isDirectory) FileUtils.copyDirectory(f, customResDir)
        else if (f.isFile) FileUtils.copyFile(f, customResDir)
        else { // try to load the resource as stream
          val res = getClass.getResource(r)
          if (res != null) {
            val in = res.openStream
            val out = new FileOutputStream(new File(customResDir, FilenameUtils.getName(r)))
            try {
              IOUtils.copy(in, out)
            } finally {
              in.close
              out.close
            }
          }
        }
      }
    }

  def generate(): Unit = {
    prepareCustomResources
    // crawl basePath for the sources
    val bp = basePath.getCanonicalPath
    val op = outputPath.getCanonicalPath
    val sources = new ListBuffer[File]
    val srcIt = FileUtils.listFiles(basePath,
      new RegexFileFilter(filenameRegex),
      TrueFileFilter.INSTANCE).asInstanceOf[JCollection[File]].iterator
    while (srcIt.hasNext)
      sources += srcIt.next
    // generate doccos
    val doccos = sources.flatMap { f =&gt;
      val docco = new Docco(f, stripScaladoc)
      if (!skipEmpty || docco.sections.size &gt; 1) {
        val fp = f.getCanonicalPath
        val relName = fp.substring(bp.length + 1) + &quot;.html&quot;
        val outFile = new File(outputPath, relName)
        FileUtils.forceMkdir(outFile.getParentFile)
        val out = new FileWriter(outFile)
        try {
          var data = Map[String, Any](
            &quot;title&quot; -&gt; f.getName,
            &quot;sections&quot; -&gt; docco.sections,
            &quot;depth&quot; -&gt; relName.toList.filter(c =&gt; c == File.separatorChar).length)
          ftlConfig.getTemplate(pageTemplate).process(data, out)
        } finally {
          out.close
        }
        Some(outFile)
      } else None
    }
    // prepare index
    val indexMap = doccos
        .groupBy(f =&gt; f.getParentFile).map { p =&gt;
      val dirName = p._1.getCanonicalPath.substring(op.length + 1)
      val filenames = p._2.map(f =&gt; f.getName.replaceAll(&quot;\\.html$&quot;, &quot;&quot;))
      (dirName -&gt; filenames)
    }
    val dirs = indexMap.keys.toList.sortBy(_.toString)
    val out = new FileWriter(new File(outputPath, &quot;index.html&quot;))
    try {
      var data = Map[String, Any](&quot;dirs&quot; -&gt; dirs, &quot;index&quot; -&gt; indexMap, &quot;title&quot; -&gt; title)
      ftlConfig.getTemplate(indexTemplate).process(data, out)
    } finally {
      out.close
    }
  }

}</code></pre>
        </td>
      </tr>
  </table>
</div>

<div id="footer">
  <span>Copyright 2009-2010 <a href="http://circumflex.ru">circumflex.ru</a></span>
</div>
<script type="text/javascript">
  try {
    var pageTracker = _gat._getTracker("UA-12034468-1");
    pageTracker._setDomainName(".circumflex.ru");
    pageTracker._trackPageview();
  } catch(err) {}</script>
</body>
</html>


# ORM: Querying

## Ordering   {#order-by}

Ordering expressions appear in `ORDER_BY` clause of `Select`, they determine how rows in
result set will be sorted. The easiest way to specify ordering expressions is to use implicit
convertions from `String` or `Field` into `Order`:

    SELECT (co.*) FROM (co) ORDER_BY (co.name)                     {.scala}

You can also add either `ASC` or `DESC` ordering specificator to explicitly set the direction of
sorting:

    SELECT (co.*) FROM (co) ORDER_BY (co.name ASC)                  {.scala}

If no specificator given, ascending sorting is assumed by default.

## Grouping & Having   {#group-by}

A query can optionally condense into a single row all selected rows that share the same value for
a subset of query [projections](/products/orm/querying/part_1.html#projection).
Such queries are often refered to as _grouping queries_
and the projections are usually refered to as _grouping projections_.

Grouping queries are built using the `GROUP_BY` clause:

    SELECT (co.*) FROM co GROUP_BY (co.*)                          {.scala}

As the example above shows, grouping projections are specified as arguments to the `GROUP_BY`
method.

Grouping queries are often used in conjunction with aggregate functions. If aggregate functions
are used, they are computed across all rows making up each group, producing separate value for
each group, whereas without `GROUP_BY` an aggregate produces a single value computed across all
the selected rows:

    val co = Country AS "co"                                       {.scala}
    val ci = City AS "ci"
    // how many cities correspond to each selected country?
    SELECT (co.* -> COUNT(ci.id)) FROM (co JOIN ci) GROUP_BY (co.*)

Groups can be optionally filtered using the `HAVING` clause. It accepts a
[predicate](/products/orm/querying/part_2.html#predicate):

    SELECT (co.* -> COUNT(ci.id)) FROM (co JOIN ci) GROUP_BY (co.*) HAVING (co.code LIKE "c_")  {.scala}

Note that `HAVING` is different from `WHERE`: `WHERE` filters individual rows before the
application of `GROUP_BY`, while `HAVING` filters group rows created by `GROUP_BY`.

## Limit & Offset   {#limit-offset}

The `LIMIT` clause specifies the maximum number of rows a query will return:

    // select 10 first countries:                                  {.scala}
    SELECT (co.*) FROM co LIMIT 10

The `OFFSET` clause specifies the number of rows to skip before starting to return results.
When both are specified, the amount of rows specified in the `OFFSET` clause is skipped before
starting to count the maximum amount of returned rows specified in the `LIMIT` clause:

    // select 5 countries starting from 10th:                      {.scala}
    SELECT (co.*) FROM co LIMIT 5 OFFSET 10

Note that query planners in database engines often take `LIMIT` and `OFFSET` into account when
generating a query plan, so you are very likely to get different row orders for different
`LIMIT`/`OFFSET` values. Thus, you should use explicit
[ordering](#order-by) to achieve
consistent and predictable results when selecting different subsets of a query result with
`LIMIT`/`OFFSET`.

# ORM: Querying

## Criteria API   {#criteria}

Most (if not all) of your data retrieval queries will be focused to retrieve only one type of
[records](/orm/ddl/part_1.html#record). _Criteria API_ aims to minimize your effort on writing
such queries. Following snippet shows three equivalents of the same query:

    // Select query:                                               {.scala}
    (Country AS "co").map(co => SELECT (co.*) FROM (co) WHERE (co.name LIKE "Sw%") list)
    // Criteria query:
    Country.criteria.add(Country.name LIKE "Sw%").list
    // or with RelationNode:
    co.criteria.add(co.name LIKE "Sw%").list

As you can see, `Criteria` queries are more compact because boilerplate `SELECT` and `FROM` clauses
are omitted.

But aside from shortening the syntax, Criteria API offers unique functionality --
[associations prefetching](#prefetch), which can greatly speed up your application when working
with graphs of associated objects.

The `Criteria[R]` object has following methods for execution:

  * `list()` executes a query and returns `Seq[R]`;
  * `unique()` executes a query and returns `Option[R]`, an exception is thrown if more than one
  row is returned from database;
  * `mkSelect` transforms a `Criteria` into the [`Select` query](/products/orm/querying/index.html#select);
  * `mkUpdate` transforms a `Criteria` into the [`Update` query](/products/orm/dml.html#update-delete);
  * `mkSelect` transforms a `Criteria` into the [`Delete` query](/products/orm/dml.html#update-delete);
  * `toString` shows query tree for debugging.

You can use [predicates](/products/orm/querying/part_2.html#predicate) to narrow the result set.
Unlike [`Select` queries](/products/orm/querying/index.html#select),
predicates are added to `Criteria` object using the `add` method and then are assembled into the
conjunction:

    co.criteria                                                    {.scala}
        .add(co.name LIKE "Sw%")
        .add(co.code LIKE "ch")
        .list

You can apply [ordering](/products/orm/querying/part_4.html#order-by) using the `addOrder` method:

    co.criteria.addOrder(co.name).addOrder(co.code).list           {.scala}

Also you can add one or more [associated](/products/orm/ddl/part_2.html#association)
[relations](/products/orm/ddl/part_1.html#relation) to the query plan
using the `addJoin` method so that you can specify constraints upon them:

    val co = Country AS "co"                                       {.scala}
    val ci = City AS "ci"
    co.criteria.addJoin(ci).add(ci.name LIKE "Lausanne").list

Automatic joins are used to update query plan properly. There is no limitation on
quantity or depth of joined relations. However, some database vendors have limitations on maximum
size of queries or maximum amount of relations participating in a single query.

One serious limitation of Criteria API is that it does not support `LIMIT` and `OFFSET` clauses
due to the fact that [association prefetching](#prefetch) normally causes result set to yield
more than one row per record. You can still use `LIMIT` and `OFFSET` with
[SQL queries](/products/orm/querying/part_4.html#limit-offset);

### Prefetching Associations   {#prefetch}

When working with [associated](/products/orm/ddl/part_2.html#association)
[records](/products/orm/ddl/part_1.html#record) you often need a whole graph of
associations to be fetched.

Normally associations are fetched eagerly first time they are accessed, but when it is done for
every record in a possibly big result set, it would result in significant performance degradation
(see the [n + 1 selects problem explained][n+1] blogpost).

With Criteria API you have an option to fetch as many associations as you want in a single query.
This technique is refered to as _associations prefetching_ or _eager fetching_.

To understand how associations prefetching works, let's take a look at the following domain model
sample:

    class Country extends Record[String, Country] {                {.scala}
      def PRIMARY_KEY = code
      def relation = Country
      val code = "code" VARCHAR(2) DEFAULT("'ch'")
      val name = "name" TEXT
      def cities = inverseMany(City.country)
    }

    object Country extends Country with Table[String, Country]

    class City extends Record[Long, City] with IdentityGenerator[Long, City] {
      def PRIMARY_KEY = id
      def relation = City
      val id = "id".LONG.NOT_NULL.AUTO_INCREMENT
      val name = "name" TEXT
      val country = "country_code".VARCHAR(2).NOT_NULL
          .REFERENCES(Country).ON_DELETE(CASCADE).ON_UPDATE(CASCADE)
    }

    object City extends City with Table[Long, City]

You see two [relations](/products/orm/ddl/part_1.html#relation), `Country` and `City`.
Each city has one [associated](/products/orm/ddl/part_2.html#association)
`country`, and, conversely, each country has a list of corresponding `cities`.

Now you wish to fetch all cities with their corresponding countries in a single query:

    val cities = City.criteria.prefetch(City.country).list         {.scala}
    cities.foreach(c => println(c.country()))   // no selects issued

The example above shows the prefetching for straight associations. Same logic applies to inverse
associations prefetching, for example, fetching all countries with their corresponding cities:

    val countries = Country.criteria.prefetch(City.country).list   {.scala}
    countries.foreach(c => println(c.cities()))   // no selects issued

Okay. Now we totally hear you saying: "How is that really possible?" -- so let's explain a bit.
Each `Criteria` object maintains it's own tree of associations, which is used to form the `FROM`
clause of the query (using [automatic left-joins](/products/orm/querying/part_3.html#joins-auto)) and,
eventually, to parse the result set. The data from result set is parsed into chunks and loaded into
transaction-scoped cache, which is subsequently used by associations and inverse
associations to avoid unnecessary selects.

There is no limitation on quantity or depth of prefetches. However, some database vendors
have limitations on maximum size of queries or maximum amount of relations participating in a
single query.

[n+1]:               http://www.pramatr.com/blog/2009/02/05/sql-n-1-selects-explained/
                        "n+1 selects explained"
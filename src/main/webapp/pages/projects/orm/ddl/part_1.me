# ORM: Data Definitions

## Record {#record}

In this example the `Country` table will have two fields, `code` and `name`.
The first type parameter, `String`, designates the type of primary key (we refer to this type as `PK`).
The second type parameter points to class itself to ensure type safety. The `Record` class has
two abstract methods which should be implemented: `PRIMARY_KEY` and `relation`.

The `PRIMARY_KEY` method points to `Field` which type matches `PK` (`String` in our example).
Primary key uniquely identifies a record in database table. Unfortunately, Circumflex ORM does not
support composite primary keys yet.

The `relation` points to companion object which corresponds to record. It must have the same name
as record class and should extend a record itself to inherit all its fields.

The body of record class contains field definitions. A field should be a public immutable (`val`) member
of record class. Each field corresponds to a column in database table.

As the example above shows, the syntax of field definition closely resembles classic DDL for generating
database schema for tables: you specify the column name with `String`, then you call one of the
methods to create a field of certain type, then you optionally call one of methods that change the
definition of target column.

Generally, spaces may be used to delimit method calls and improve readability of column definitions.
However, sometimes Scala compiler forces you to use dot-notation:

    val name = "name".TEXT.NOT_NULL                               {.scala}

Following methods are used to create field definitions:

<table width="100%">
  <thead>
  <tr>
    <th>Method</th>
    <th>SQL type</th>
    <th>Scala type</th>
    <th>Implementing class</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><code>INTEGER</code></td>
    <td><code>INTEGER</code></td>
    <td><code>Int</code></td>
    <td><code>IntField</code></td>
  </tr>
  <tr>
    <td><code>BIGINT</code></td>
    <td><code>BIGINT</code></td>
    <td><code>Long</code></td>
    <td><code>LongField</code></td>
  </tr>
  <tr>
    <td><code>DOUBLE(precision: Int, scale: Int)</code></td>
    <td><code>NUMERIC(p, s)</code></td>
    <td><code>Double</code></td>
    <td><code>DoubleField</code></td>
  </tr>
  <tr>
    <td><code>NUMERIC(precision: Int, scale: Int
        roundingMode: BigDecimal.RoundingMode.RoundingMode)</code></td>
    <td><code>NUMERIC(p, s)</code></td>
    <td><code>scala.math.BigDecimal</code></td>
    <td><code>NumericField</code></td>
  </tr>
  <tr>
    <td><code>TEXT</code></td>
    <td><code>TEXT</code></td>
    <td><code>String</code></td>
    <td><code>TextField</code></td>
  </tr>
  <tr>
    <td><code>VARCHAR(length: Int)</code></td>
    <td><code>VARCHAR(l)</code></td>
    <td><code>String</code></td>
    <td><code>TextField</code></td>
  </tr>
  <tr>
    <td><code>BOOLEAN</code></td>
    <td><code>BOOLEAN</code></td>
    <td><code>Boolean</code></td>
    <td><code>BooleanField</code></td>
  </tr>
  <tr>
    <td><code>DATE</code></td>
    <td><code>DATE</code></td>
    <td><code>java.util.Date</code></td>
    <td><code>DateField</code></td>
  </tr>
  <tr>
    <td><code>TIME</code></td>
    <td><code>TIME</code></td>
    <td><code>java.util.Date</code></td>
    <td><code>TimeField</code></td>
  </tr>
  <tr>
    <td><code>TIMESTAMP</code></td>
    <td><code>TIMESTAMP</code></td>
    <td><code>java.util.Date</code></td>
    <td><code>TimestampField</code></td>
  </tr>
  </tbody>
</table>

In the table above the default SQL types show the types defined in default dialect,
which can be overriden in vendor-specific dialects. Besides it is possible to define a field with
custom SQL type by subclassing the `Field` class.
Refer to [Circumflex ORM API documentation](/api/2.0/circumflex-orm/field.scala) for details.

Since version 2.0 genearated columns *will not have* `NOT NULL` constraints by default (this
behavior is consistent with SQL specifications). You should call `NOT_NULL` method to express
`NOT NULL` constraint in column definition:

    val mandatory = "mandatory".TEXT.NOT_NULL                     {.scala}
    val optional = "optional".TEXT

You can optionally initialize a field with value with `NOT_NULL`:

    val createdAt = "created_at".TIMESTAMP.NOT_NULL(new Date)     {.scala}

You can also specify the default expression for the field, it will be rendered in database
column definition:

    val radius = "radius".NUMERIC.NOT_NULL                        {.scala}
    val square = "square".NUMERIC.NOT_NULL.DEFAULT("PI() * (radius ^ 2)")

You can also create a single-column unique constraint using the `UNIQUE` method:

    val login = "login".VARCHAR(64).NOT_NULL.UNIQUE               {.scala}

Fields operate with values. The syntax for accessing and setting values is self-descriptive:

    val age = "age".INTEGER  // Field[Int, R]                     {.scala}
    // accessing
    age.value                     // Option[Int]
    age.get                       // Option[Int]
    age()                         // Int
    age.getOrElse(default: Int)   // Int
    age.null_?                    // Boolean
    // setting
    age := 25
    age.set(25)
    age.set(Some(25))
    age.set(None)
    age.setNull

It is a good practice to place domain-specific logic inside record classes. The following example
shows the most trivial case: overriding `toString` and providing alternative constructor:

    class Country extends Record[String, Country] {               {.scala}
      def PRIMARY_KEY = code
      def relation = Country
      // Constructor shortcuts
      def this(code: String, name: String) = {
        this()
        this.code := code
        this.name := name
      }
      // Fields
      val code = "code" VARCHAR(2) DEFAULT("'ch'")
      val name = "name" TEXT
      // Miscellaneous
      override def toString = name.getOrElse("Unknown")
    }

## Relation   {#relation}

Relation is defined as a companion object for corresponding [record](#record). As mentioned before,
the relation object should have the same name as its corresponding record class, should extend
that record class and should mix in one of the `Relation` traits (`Table` or `View`):

    class Country extends Record[String, Country] {               {.scala}
      def relation = Country
      // ...
    }
    object Country extends Country with Table[String, Country]

You can place the definitions of constraints and indexes inside the body of relation, they should
be public immutable (`val`) members of relation:

    object Country extends Country with Table[String, Country] {  {.scala}
      // a named UNIQUE constraint
      val codeKey = CONSTRAINT("code_uniq").UNIQUE(this.code)
      // a UNIQUE constraint with default name
      val codeKey = UNIQUE(this.code)
      // a named CHECK constraint:
      val codeChk = CONSTRAINT("code_chk").CHECK("code IN ('ch', 'us', 'uk', 'fr', 'es', 'it', 'pt')")
      // a named FOREIGN KEY constraint:
      val fkey = CONSTRAINT("eurozone_code_fkey").FOREIGN_KEY(EuroZone, this.code -> EuroZone.code)
      // an index:
      val idx = "country_code_idx".INDEX("LOWER(code)").USING("btree").UNIQUE
    }

Consult [Circumflex ORM API Documentation](/api/2.0/circumflex-orm/sql.scala) for other
definition options.

The relation object is also the right place for various querying methods:

    object User extends Table[Long, User] {                       {.scala}
      def findByLogin(l: String): Option[User] = (this AS "u").map(u =>
          SELECT(u.*).FROM(u).WHERE(u.login LIKE l).unique)
    }

See [querying](/products/orm/querying/index.html#sql), [data manipulation](/products/orm/dml.html#dml) and
[Criteria API](/products/orm/querying/part_6.html#criteria) sections for
more information.